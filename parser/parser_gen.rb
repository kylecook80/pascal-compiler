functions = %w[program program_prime program_double_prime identifier_list identifier_list_prime declarations declarations_prime type_prod standard_type subprogram_declarations subprogram_declarations_prime subprogram_declaration subprogram_declaration_prime subprogram_declaration_double_prime subprogram_head subprogram_head_prime arguments parameter_list parameter_list_prime compound_statement compound_statement_prime optional_statements statement_list statement_list_prime statement statement_prime variable variable_prime procedure_statement procedure_statement_prime expression_list expression_list_prime expression expression_prime simple_expression simple_expression_prime term term_prime factor factor_prime sign]

str = []

str << "package parser"
str << ""
str << "import ("
str << ". \"compiler/scanner\""
str << ". \"compiler/util\""
str << "\"fmt\""
str << "\"io\""
str << "\"io/ioutil\""
str << "\"strconv\""
str << "\"time\""
str << ")"
str << ""

str << "type Parser struct {"
str << "scanner   *Scanner"
str << "tok       Token"
str << "listing   *ListingFile"
str << "tokenFile []byte"
str << "source    *Buffer"
str << "}"
str << ""

str << "func NewParser(scanner *Scanner) Parser {"
str << "return Parser{scanner: scanner}"
str << "}"
str << ""

str << "func (parser *Parser) Begin(file string) {"
str << "listing := NewListingFile()"
str << "tokenFile := []byte{}"
str << "source := ReadFile(file)"
str << ""
str << "parser.listing = listing"
str << "parser.source = source"
str << "parser.tokenFile = tokenFile"
str << ""
str << "parser.program()"
str << ""
str << "ioutil.WriteFile(GenerateTimeString(time.Now())+\"_token_file.txt\", parser.tokenFile, 0644)"
str << "parser.listing.Save()"
str << "}"
str << ""

str << "func (parser *Parser) nextTok() {"
str << "tok, err := parser.scanner.NextToken()"
str << ""
str << "if parser.scanner.CurrentLineNumber() >= parser.listing.LineCount() {"
str << "parser.listing.AddLine(parser.source.ReadLine(parser.scanner.CurrentLineNumber()))"
str << "}"
str << ""
str << "if err == io.EOF {"
str << "parser.tok = Token{}"
str << "return"
str << "} else if err != nil {"
str << "parser.listing.AddError(err.Error())"
str << "} else {"
str << "line := parser.scanner.CurrentLineNumber() + 1"
str << "if tok.Type() != WS {"
str << "newTokenFile := append(parser.tokenFile, []byte(strconv.Itoa(line)+\": \"+tok.String()+\"\\n\")...)"
str << "parser.tokenFile = newTokenFile"
str << "}"
str << "}"
str << ""
str << "parser.tok = tok"
str << "}"
str << ""

str << "func (parser *Parser) accept(t interface{}) bool {"
str << "for parser.tok.Type() == WS {"
str << "parser.nextTok()"
str << "}"
str << ""
str << "switch sym := t.(type) {"
str << "case TokenType:"
str << "if parser.tok.Type() == sym {"
str << "parser.nextTok()"
str << "return true"
str << "}"
str << "case Attribute:"
str << "if parser.tok.Attr() == sym {"
str << "parser.nextTok()"
str << "return true"
str << "}"
str << "}"
str << ""
str << "return false"
str << "}"
str << ""

str << "func (parser *Parser) expect(t interface{}) {"
str << "if parser.accept(t) {"
str << "return"
str << "} else {"
str << "fmt.Println(\"Error: unexpected symbol: \"+ parser.tok.Value())"
str << "fmt.Printf(\"token type: %s\\n\", TokenStrings[parser.tok.Type()])"
str << "parser.nextTok()"
str << "}"
str << "}"

functions.each do |name|
  str << "func (parser *Parser) #{name}() {"
  str << ""
  str << "}"
  str << ""
end

File.open("parser.go", "w") do |f|
  f.puts str
end

`go fmt`
